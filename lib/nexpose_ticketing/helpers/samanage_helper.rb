require 'rubygems'
require 'httpi'
require 'uri'
require 'csv'
require 'gyoku'
require 'nokogiri'
require 'nexpose_ticketing/nx_logger'


# This class serves as the Samanage interface that creates Incident tickets within Samanage from 
# vulnerabilities found in Nexpose. Copyright (c) 2015 Rapid7, LLC.
class SamanageHelper
  attr_accessor :samanage_data, :options, :nxdata
  def initialize(samanage_data, options, nxdata)
    @samanage_data = samanage_data
    @options = options
    @nxdata = nxdata
    @log = NexposeTicketing::NXLogger.new
  end

  # Sends a list of tickets (in XML format) to Samanage individually (each ticket in the list 
  # as a separate HTTP POST request).
  #
  # * *Args*    :
  #   - +tickets+ -  List of XML-formatted Incident tickets.
  #
  def create_tickets(tickets)
    fail 'Ticket(s) cannot be empty.' if tickets.empty? || tickets.nil?
    raise ArgumentError, 'HTTP Redirect too deep' if @samanage_data[:redirect_limit] == 0
    create_ticket_url = @samanage_data[:samanage_url]

    if @samanage_data[:notifications] == 'Y' then create_ticket_url += "?add_callbacks=true" end

    req = HTTPI::Request.new(create_ticket_url)
    req.ssl = true
    req.follow_redirect = true
    req.open_timeout = @samanage_data[:open_timeout]
    req.read_timeout = @samanage_data[:read_timeout]
    req.headers = { 'Content-Type' => 'text/xml',
                    'Accept' => @samanage_data[:api_version] }  

    req.auth.ssl.verify_mode = :peer
    req.auth.ssl.ssl_version = :TLSv1
    req.auth.digest(@samanage_data[:username], @samanage_data[:password])

    tickets.each do |ticket|
      req.body = ticket      
      @log.log_message("Creating ticket at: #{req.url.to_s}")
      resp = HTTPI.post(req, :httpclient)  
      case resp.code
        when 200..299 then @log.log_message("HTTP request successful: #{resp.code} (#{req.url.to_s}) - (#{resp.headers})")
        when 301..308 then @log.log_message("HTTP request redirected: #{resp.code} (#{req.url.to_s}) - (#{resp.headers}) - #{resp.body}")
      else
         @log.log_message("Error in HTTP response: #{resp.code} (#{create_ticket_url}) - (#{resp.headers}) - #{resp.body}")
      end
    end
  end

  # Sends ticket updates (in XML format) to Samanage individually (each ticket in the list as a 
  # separate HTTP post).
  #
  # * *Args*    :
  #   - +tickets+ -  List of XML-formatted ticket updates.
  #
  def update_tickets(tickets)
    raise ArgumentError, 'HTTP Redirect too deep' if @samanage_data[:redirect_limit] == 0
    if tickets.nil? || tickets.empty?
      @log.log_message("No tickets to update.")
    else
      update_notify_flag = ""
      if @samanage_data[:notifications] == 'Y' then update_notify_flag += "?add_callbacks=true" end

      req = HTTPI::Request.new(@samanage_data[:samanage_update_url])
      req.ssl = true
      req.follow_redirect = true
      req.open_timeout = @samanage_data[:open_timeout]
      req.read_timeout = @samanage_data[:read_timeout]
      req.headers = { 'Content-Type' => 'text/xml',
                      'Accept' => @samanage_data[:api_version] }  

      req.auth.ssl.verify_mode = :peer
      req.auth.ssl.ssl_version = :TLSv1
      req.auth.digest(@samanage_data[:username], @samanage_data[:password])
        
      tickets.each do |ticket|
        ticket_xml = Nokogiri::XML(ticket) do |config|
          config.strict.nonet
        end
        req.url = ticket_xml.search("//href").inner_text + update_notify_flag
        req.body = ticket
        @log.log_message("Updating ticket at: #{req.url.to_s}")
        resp = HTTPI.put(req, :httpclient)  
        case resp.code
          when 200..299 then @log.log_message("HTTP request successful: #{resp.code} (#{req.url.to_s}) - (#{resp.headers})")
          when 301..308 then @log.log_message("HTTP request redirected: #{resp.code} (#{req.url.to_s}) - (#{resp.headers}) - #{resp.body}")
        else
         @log.log_message("Error in HTTP response: #{resp.code} (#{req.url.to_s}) - (#{resp.headers}) - #{resp.body}")
        end
      end
    end
  end
  
  # Sends ticket closure (in XML format) to Samanage individually (each ticket in the list as a 
  # separate HTTP post). Uses same update API URL and HTTP method as update_tickets.
  #
  # * *Args*    :
  #   - +tickets+ -  List of XML-formatted ticket closures.
  #
  def close_tickets(tickets)
    if tickets.nil? || tickets.empty?
      @log.log_message("No tickets to close.")
    else
      update_tickets(tickets)
    end
  end

  # Sends a query to Samanage to return back a single ticket's URL based on the criteria.
  #
  # * *Args*    :
  #   - +unique_id+ -  Unique identifier generated by the helper.
  #
  # * *Returns* :
  #   - Samanage information in XML format or nil if no results are found.
  #
  def query_for_ticket(unique_id)
    emptyresponse = ""
    req = HTTPI::Request.new(@samanage_data[:samanage_url])
    req.ssl = true
    req.follow_redirect = true
    req.open_timeout = @samanage_data[:open_timeout]
    req.read_timeout = @samanage_data[:read_timeout]    
    req.headers = { 'Content-Type' => 'text/xml',
                    'Accept' => @samanage_data[:api_version] }  

    req.auth.ssl.verify_mode = :peer
    req.auth.ssl.ssl_version = :TLSv1
    req.query = { :description => "*#{unique_id}*" }
    req.auth.digest(@samanage_data[:username], @samanage_data[:password])

    @log.log_message("HTTP request query: #{req.url.to_s}")

    resp = HTTPI.get(req, :httpclient)  
    case resp.code
      when 200..299 then @log.log_message("HTTP request successful: ##{resp.code} - (#{resp.headers})")
      when 301..308 then @log.log_message("HTTP request redirected: #{resp.code} - (#{resp.headers})")
    else
      @log.log_message("Error in response: #{resp.code} - (#{resp.headers}) - #{resp.body}")
    end

    if resp.body.include? "</nil_classes>" 
      emptyresponse
    else
      resp_xml = Nokogiri::XML(resp.body) do |config|
        config.strict.nonet
      end
      query_url = resp_xml.search("//href").inner_text
      query_url
    end
  end

  # Determines Samanage ticket assignee based on asset OS
  #
  # * *Args*    :
  #   - +asset_os+ - Asset OS name, including family, vendor, name, and version.
  #
  # * *Returns* :
  #   - Samanage assignee as defined in samanage.config.
  #
  def find_assignee_by_os(asset_os)
    @log.log_message("Finding assignee for asset OS #{asset_os}.")
    case
      when Array(@samanage_data[:nix_os]).any? {|os| asset_os.include?(os)}
        @samanage_data[:nix_assignee]
      when Array(@samanage_data[:net_os]).any? {|os| asset_os.include?(os)}
        @samanage_data[:net_assignee]
      when Array(@samanage_data[:win_os]).any? {|os| asset_os.include?(os)}
        @samanage_data[:win_assignee]
      when Array(@samanage_data[:vm_os]).any? {|os| asset_os.include?(os)}
        @samanage_data[:vm_assignee]  
    else
      @samanage_data[:def_assignee]
    end      
  end

  # Prepare tickets from the CSV of vulnerabilities exported from Nexpose. This method determines 
  # how to prepare the tickets (by default, by IP address or by vulnerability) based on config options.
  #
  # * *Args*    :
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated tickets for creating within Samanage.
  #
  def prepare_create_tickets(vulnerability_list, site_id)
    @ticket = Hash.new(-1)
    case @options[:ticket_mode]
    # 'D' Default IP *-* Vulnerability
    when 'D'
      prepare_create_tickets_default(vulnerability_list, site_id)
    # 'I' IP address -* Vulnerability
    when 'I'
      prepare_create_tickets_by_ip(vulnerability_list, site_id)
    # 'V' Vulnerability mode: Vulnerability -* IP address
    when 'V'
      prepare_create_tickets_by_vulnerability(vulnerability_list, site_id)
    else
        fail 'No ticketing mode selected.'
    end
  end

    # Prepare to update tickets from the CSV of vulnerabilities exported from Nexpose. This method determines
  # how to prepare the tickets for update (by IP address or by vulnerability) based on config options.
  #
  # * *Args*    :
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated (hash) tickets for creating within Samanage.
  #
  def prepare_update_tickets(vulnerability_list, site_id)
    @ticket = Hash.new(-1)
    case @options[:ticket_mode]
      # 'I' IP address mode: IP address -* Vulnerability
      when 'I'
        prepare_update_tickets_by_ip(vulnerability_list, site_id)
      # 'V' Vulnerability mode: Vulnerability -* IP address
      when 'V'
        prepare_update_tickets_by_vulnerability(vulnerability_list, site_id)
      else
        fail 'No ticketing mode selected.'
    end
  end

    # Creates string for asset name to be added to ticket description unless asest name is blank
  #
  # * *Args*    :
  #   - +asset_name+ -  Asset name for an IP address in Nexpose
  #
  # * *Returns* :
  #   - Returns String - Asset name to be added to ticket description
  #
  def create_asset_name_string(asset_name)
    if asset_name.nil?
      asset_name_string = ""
    else
      asset_name_string = " (#{asset_name})"
    end
    return asset_name_string
  end

  # Prepares a list of vulnerabilities into a list of XML-formatted tickets (Incidents) for 
  # Samanage. The preparation by default means that each vulnerability within Nexpose is a 
  # separate Incident within Samanage.  This makes for smaller, more actionalble Incidents but 
  # could lead to a very large total number of Incidents overall.
  #
  # * *Args*    :
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated tickets for creating within samanage.
  #
  def prepare_create_tickets_default(vulnerability_list, site_id)
    @log.log_message("Preparing tickets by default method.")
    tickets = []
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
      @log.log_message("Creating ticket with IP address #{row['ip_address']} and vulnerability #{row['vulnerability_title']}")
      # NXID in the work_notes is a unique identifier used to query Incidents to update/resolve 
      # Incidents as they are resolved in Nexpose.
      ticket =  { 
        "name" => "Remediation request for \"#{row['vuln_title']}\" on #{row['ip_address']}",
        "requester!" => "#{@samanage_data[:requester]}",
        "priority" => "#{@samanage_data[:priority]}",
        "description" => "Please remediate #{row['vuln_title']} on <a href=\"https://#{@nxdata[:nxconsole]}:#{@nxdata[:nxport]}/asset.jsp?devid=#{row['asset_id']}\">
                          #{row['ip_address']}#{create_asset_name_string(row['host_name'])}</a>.
                          \n\n<strong>#{row['vuln_title']}:</strong> #{row['fix']}
                          \n\nNXID: #{site_id}#{row['asset_id']}#{row['vulnerability_id']}#{row['solution_id']}",          
        
        "assignee_id" => "#{find_assignee_by_os(row['asset_os'])}",
        "category!" => "<name>#{@samanage_data[:category]}</name>",
        "subcategory!" => "<name>#{@samanage_data[:subcategory]}</name>",
        "state" => "Assigned",
        "site!" => "<name>#{@samanage_data[:site]}</name>",
        "department!" => "<name>#{@samanage_data[:department]}</name>"
      }
      tickets.push(Gyoku.xml(:incident => ticket))
    end
    tickets
  end

  # Prepares a list of vulnerabilities into a list of XML-formatted tickets (Incidents) for 
  # Samanage. The preparation by IP means that all vulnerabilities within Nexpose for one IP 
  # address are consolidated into a single Samanage Incident. This reduces the number of Incidents
  # within Samanage but greatly increases the size of the ticket notes.
  #
  # * *Args*    :
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated tickets for creating within Samanage.
  #
  def prepare_create_tickets_by_ip(vulnerability_list, site_id)
    @log.log_message('Preparing tickets by IP address.')
    tickets = []
    current_ip = -1
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
      if current_ip == -1 
        current_ip = row['ip_address']
        @log.log_message("Creating ticket with IP address: #{row['ip_address']}, Asset ID: #{row['asset_id']}, OS: #{row['asset_os']}, and Site ID: #{site_id}")
        @ticket = { 
          "name" => "Remediate #{@samanage_data[:severity]} vulnerabilities on #{row['ip_address']}",
          "requester!" => "#{@samanage_data[:requester]}",
          "priority" => "#{@samanage_data[:priority]}",          
          "description" => "Please remediate the following vulnerabilities on <a href=\"https://#{@nxdata[:nxconsole]}:#{@nxdata[:nxport]}/asset.jsp?devid=#{row['asset_id']}\">
                            #{row['ip_address']}#{create_asset_name_string(row['host_name'])}</a>:<br><br><ul>", 
          "assignee_id" => "#{find_assignee_by_os(row['asset_os'])}",
          "category!" => "<name>#{@samanage_data[:category]}</name>",
          "subcategory!" => "<name>#{@samanage_data[:subcategory]}</name>",
          "state" => "Assigned",
          "site!" => "<name>#{@samanage_data[:site]}</name>",
          "department!" => "<name>#{@samanage_data[:department]}</name>"
        }
      end
      if current_ip == row['ip_address']
        @ticket['description'] += "<li><strong>#{row['vuln_title']}:</strong> #{row['fix']}<br>"                                  
        # Only add the URL block if data exists in the row.          
        if row['url'].nil?
          @ticket['description'] += "</li><br>"
        else          
          @ticket['description'] += "^More info: #{row['url']}</li><br>"
        end        
      end
      unless current_ip == row['ip_address']
        # NXID in the description is the unique identifier used to query Incidents to update them.
        @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_ip}"
        @ticket = Gyoku.xml(:incident => @ticket)
        tickets.push(@ticket)
        current_ip = -1
        redo
      end
    end
    # NXID in the description is the unique identifier used to query Incidents to update them.
    @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_ip}"
    tickets.push(Gyoku.xml(:incident => @ticket)) unless @ticket.nil?
    tickets
  end

  # Prepares a list of vulnerabilities into a list of XML-formatted tickets (Incidents) for
  # Samanage. The preparation by vulnerability means that all IP addresses within Nexpose for one vulnerability
  # are consolidated into a single Samanage Incident. This reduces the number of Incidents
  # within Samanage but greatly increases the size of the work notes.
  #
  # * *Args*    :
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated (hash) tickets for creating within Samanage.
  #
  def prepare_create_tickets_by_vulnerability(vulnerability_list, site_id)
    @log.log_message('Preparing tickets by vulnerability.')
    tickets = []
    current_vuln_id = -1
    current_solution_id = -1
    current_asset_id = -1
    vulnerability_list_header = vulnerability_list[0]
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
    #New vulnerability ID (the query sorting criteria).
    if current_vuln_id == -1
      current_vuln_id = row['vulnerability_id']
      current_solution_id = row['solution_id']
      current_asset_id =  row['asset_id']
      @log.log_message("Creating ticket with Vulnerability ID: #{row['vulnerability_id']}, Asset ID: #{row['asset_id']} and Site ID: #{site_id}")

      @ticket = {
          "name" => "Remediate \"#{row['vuln_title']}\" vulnerability",
          "requester!" => "#{@samanage_data[:requester]}",
          "priority" => "#{@samanage_data[:priority]}",          
          "description" => "Please remediate \"#{row['vuln_title']}\" on the systems listed below (remediation steps are provided for each one).<br><br>
                            <strong>Description:</strong> #{row['vuln_description']}<br><br>
                            <ul><li><strong>#{row['ip_address']}</strong>: #{row['fix']}</li><br>", 
          "assignee_id" => "#{@samanage_data[:def_assignee]}",
          "category!" => "<name>#{@samanage_data[:category]}</name>",
          "subcategory!" => "<name>#{@samanage_data[:subcategory]}</name>",
          "state" => "Assigned",
          "site!" => "<name>#{@samanage_data[:site]}</name>",
          "department!" => "<name>#{@samanage_data[:department]}</name>"
        }  
    end
    if current_vuln_id == row['vulnerability_id']
      #Add solutions for the now affected assets.
      if current_solution_id != row['solution_id']
        same_solution_text = "<li><strong>#{row['ip_address']}</strong>: Same solution as above</li><br>"
        new_solution_text =  "<li><strong>#{row['ip_address']}</strong>: #{row['fix']}"
        if  @ticket['description'].include? new_solution_text
          @log.log_message('Ignoring duplicate solution in ticket creation.')
          @ticket['description'] += same_solution_text
        else
          @ticket['description'] += new_solution_text
          #Add any references.
          if row['url'].nil?
            @ticket['description'] += "</li><br>"
          else          
            @ticket['description'] += "\n^More info: #{row['url']}</li><br>"
          end      
        end
        current_solution_id = row['solution_id']
      end

      #Added the new asset to the list of affected systems if it is different (could have been the same asset with a different solution ID).
      if current_asset_id != row['asset_id']
        #@ticket['assets'] += "<asset><ip>#{row['ip-address']}</ip></asset>" #As of 2014-11-21: not ready to be used unless assets in NX are also populated in Samanage ahead of time
        #@ticket['description'] += "<li>#{row['ip-address']}</li>"
        current_asset_id = row['asset_id']
      end
    end
    unless current_vuln_id == row['vulnerability_id']
      # NXID in the work_notes is the unique identifier used to query incidents to update them.
      @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_asset_id}#{current_vuln_id}"
      current_vuln_id = -1
      current_solution_id = -1
      current_asset_id = -1
      @ticket = Gyoku.xml(:incident => @ticket)
      tickets.push(@ticket)
      redo
    end
  end
  # NXID in the work_notes is the unique identifier used to query incidents to update them.
  @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_asset_id}#{current_vuln_id}"
  @ticket = Gyoku.xml(:incident => @ticket)
  tickets.push(@ticket) unless @ticket.nil?
  tickets
  end

  def format_notes_by_vulnerability(ticket, prepend)
    nxid_holder = ticket['description']
    ticket['description'] = ''
    ticket['description'] += prepend unless prepend.nil?
    ticket['description'] += ticket['description'] += "\n\n"
    ticket['description'] += ticket['workaround'] += "\n\n"
    ticket['description'] += nxid_holder
    #ticket.delete("assets") #As of 2014-11-21: not ready to be used unless assets in NX are also populated in Samanage ahead of time
    ticket.delete("workaround")
    ticket = Gyoku.xml(:incident => ticket)
    ticket
  end

  # Prepare ticket updates from the CSV of vulnerabilities exported from Nexpose. This method 
  # currently only supports updating IP-address mode tickets in Samanage. The list of vulnerabilities 
  # are ordered by IP address and then by ticket_status, allowing the method to loop through and  
  # display new, old, and same vulnerabilities in that order.
  #
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated tickets for updating within Samanage.
  #
  def prepare_update_tickets_by_ip(vulnerability_list, site_id)
    fail 'Ticket updates are only supported in IP-address mode.' if @options[:ticket_mode] != 'I'
    @ticket = Hash.new(-1)
    
    @log.log_message("Preparing ticket updates by IP address.")
    tickets = []
    current_ip = -1
    ticket_status = 'New'
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
      if current_ip == -1 
        current_ip = row['ip_address']
        ticket_status = row['comparison']
        
        # Query Samanage for the Incident by unique id (generated NXID)
        queried_incident = query_for_ticket("NXID: #{site_id}#{row['ip_address']}")
        @log.log_message("Looking to update ticket with NXID: #{site_id}#{row['ip_address']}") 
        if queried_incident.nil? || queried_incident.empty?
          @log.log_message("No Incident found for NXID: #{site_id}#{row['ip_address']}") 
        else
          @log.log_message("Creating ticket update for #{row['ip_address']} at #{queried_incident}")
          @log.log_message("Ticket status #{ticket_status}")
          @ticket = {
          "description" => "Please remediate the following vulnerabilities on <a href=\"https://#{@nxdata[:nxconsole]}:#{@nxdata[:nxport]}/asset.jsp?devid=#{row['asset_id']}\">
                            #{row['ip_address']}#{create_asset_name_string(row['host_name'])}</a>:<br><br><strong>***#{row['comparison']} Vulnerabilities***</strong><ul>",
          "href" => "#{queried_incident}"
                      }
        end
      end
      if current_ip == row['ip_address']
        # If the ticket_status is different, add a a new 'header' to signify a new block of tickets.       
        unless ticket_status == row['comparison']
          @ticket['description'] += "</ul><br><br><strong>***#{row['comparison']} Vulnerabilities***</strong><ul>"
          ticket_status = row['comparison']
        end
        @ticket['description'] += "<li><strong>#{row['vuln_title']}:</strong> #{row['fix']}<br>"

        # Only add the URL block if data exists in the row.
        if row['url'].nil?
          @ticket['description'] += "</li><br>"
        else          
          @ticket['description'] += "^More info: #{row['url']}</li><br>"
        end 
      end
      unless current_ip == row['ip_address']
        # NXID in the description is the unique identifier used to query Incidents to update them.
        @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_ip}"
        @ticket = Gyoku.xml(:incident => @ticket)
        tickets.push(@ticket)
        current_ip = -1
        redo
      end
    end
    # NXID in the description is the unique identifier used to query Incidents to update them.
    @ticket['description'] += "</ul>\n\n\nNXID: #{site_id}#{current_ip}" unless @ticket.empty?
    tickets.push(Gyoku.xml(:incident => @ticket)) unless @ticket.nil? || @ticket.empty?
    tickets
  end

  # Prepare ticket updates from the CSV of vulnerabilities exported from Nexpose. This method
  # currently only supports updating vulnerability mode tickets in Samanage. The list of vulnerabilities
  # are ordered by vulnerability ID and then by ticket_status, allowing the method to loop through and
  # display new, old, and same vulnerabilities in that order.
  #
  #   - +vulnerability_list+ -  CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated (hash) tickets for updating within Remedy.
  #
  def prepare_update_tickets_by_vulnerability(vulnerability_list, site_id)
    fail 'Ticket updates are only supported in IP-address mode.' if @options[:ticket_mode] != 'V'
    @ticket = Hash.new(-1)

    @log.log_message('Preparing ticket updates by IP address.')
    tickets = []
    current_vuln_id = -1
    current_solution_id = -1
    current_asset_id = -1
    current_solutions_text = "\n++ Details ++++++++++++++\n"
    ticket_status = 'New'
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
      if current_vuln_id == -1
        current_solutions_text = "\n++ Details +++++++++++++++\n"
        current_vuln_id = row['vulnerability_id']
        ticket_status = row['comparison']
        current_asset_id = -1
        current_solution_id = -1

        # Query Samanage for the incident by unique id (generated NXID)
        queried_incident = query_for_ticket("NXID: #{site_id}#{row['asset_id']}#{row['vulnerability_id']}")
        if queried_incident.nil? || queried_incident.empty?
          @log.log_message("No incident found for NXID: #{site_id}#{row['asset_id']}#{row['vulnerability_id']}#{row['solution_id']}. Creating...")
          new_ticket_csv = vulnerability_list.split("\n").first
          new_ticket_csv += "\n#{row.to_s}"
          new_ticket = prepare_create_tickets_by_vulnerability(new_ticket_csv, site_id)
          @log.log_message('Created ticket. Sending to Remedy...')
          create_tickets(new_ticket)
          @log.log_message('Ticket sent. Performing update for ticket...')
          #Now that there is a ticket for this NXID update it as if it existed this whole time...
          current_vuln_id = -1
          redo
        else
          @log.log_message("Creating ticket update for vulnerability with ID: #{row['vulnerability_id']}, Asset ID:  #{row['asset_id']} and Site ID: #{site_id}. Ticket status #{ticket_status}.")
          @ticket = {
          "description" => "Please remediate #{row['vuln_title']} on the following assets:\n\n<strong>***#{row['comparison']} Assets***</strong><ul>",
          "href" => "#{queried_incident}"
          }
        end
      end
      if current_vuln_id == row['vulnerability_id']
        # If the ticket_status is different, add a a new 'header' to signify a new block of tickets.
        unless ticket_status == row['comparison']
          @ticket['description'] +=
              "\n\n\n<strong>***#{row['comparison']} Assets***</strong>\n"
          ticket_status = row['comparison']
        end

        #Added the new asset to the list of affected systems if it is different (could have been the same asset with a different solution ID).
        if current_asset_id != row['asset_id']
          @ticket['description'] += "#{row['ip_address']}, "
          current_asset_id = row['asset_id']
        end

        #Add solutions for the now affected assets.
        if current_solution_id != row['solution_id']
          new_solution_text =  "\n<strong>Summary:</strong> #{row['summary']} \nFix: #{row['fix']}\n"
          if current_solutions_text.include? new_solution_text
            @log.log_message('Ignoring duplicate solution for ticket update.')
          else
          current_solutions_text += new_solution_text
            #Add any references.
            unless row['url'].nil?
              current_solutions_text +=
                  "\nURL: #{row['url']}"
            end
          end
          current_solution_id = row['solution_id']
        end
      end
      unless current_vuln_id == row['vulnerability_id']
        # NXID in the work_notes is the unique identifier used to query incidents to update them.
        @ticket['description'] += "\n\n" + current_solutions_text
        @ticket['description'] += "\n\nNXID: #{site_id}#{current_asset_id}#{current_vuln_id}"
        tickets.push(@ticket)
        current_vuln_id = -1
        current_solution_id = -1
        current_asset_id = -1
        redo
      end
    end
    # NXID in the work_notes is the unique identifier used to query incidents to update them.
    @ticket['description'] += current_solutions_text
    @ticket['description'] += "\n\nNXID: #{site_id}#{current_asset_id}#{current_vuln_id}" unless @ticket.empty?
    tickets.push(@ticket) unless @ticket.nil? || @ticket.empty?
    tickets
  end

  # Prepare ticket closures from the CSV of vulnerabilities exported from Nexpose.
  #
  # * *Args*    :
  #   - +vulnerability_list+ - CSV of vulnerabilities within Nexpose.
  #
  # * *Returns* :
  #   - List of XML-formated (hash) tickets for closing within Samanage.
  #
  def prepare_close_tickets(vulnerability_list, site_id)
    @log.log_message("Preparing ticket closures by method #{@options[:ticket_mode]}.")
    @nxid = nil
    tickets = []
    CSV.parse(vulnerability_list.chomp, headers: :first_row)  do |row|
      case @options[:ticket_mode]
        # 'D' Default mode: IP *-* Vulnerability
        when 'D'
          @nxid = "#{site_id}#{row['asset_id']}#{row['vulnerability_id']}#{row['solution_id']}"
        # 'I' IP address mode: IP address -* Vulnerability
        when 'I'
          @nxid = "#{site_id}#{row['current_ip']}"
        # 'V' Vulnerability mode: Vulnerability -* IP address
        when 'V'
          @nxid = "#{site_id}#{row['current_asset_id']}#{row['current_vuln_id']}"
        else
          fail 'Could not close tickets - cannot understand the ticketing mode!'
      end
      # Query Samanage for the Incident by unique id (generated NXID)
      queried_incident = query_for_ticket("NXID: #{@nxid}")
      @log.log_message("Looking to close ticket with NXID: #{@nxid}") 
      if queried_incident.nil? || queried_incident.empty?
        @log.log_message("No Incident found for NXID: #{@nxid}") 
      else
        ticket = {
          "state" => 'Resolved'
        }
        tickets.push(Gyoku.xml(:incident => ticket)) unless ticket.nil?
      end
    end
    tickets
  end  
end